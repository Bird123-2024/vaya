import chalk from 'chalk';
import { join, relative } from 'path';
import { createFunction } from '@zeit/fun';
import { readFile, stat, mkdirp } from 'fs-extra';
import ignore, { Ignore } from '@zeit/dockerignore';
import FileFsRef from '@now/build-utils/file-fs-ref';

import { globBuilderInputs } from './glob';
import DevServer from './dev-server';
import wait from '../../../util/output/wait';
import IGNORED from '../../../util/ignored';
import { NowError } from '../../../util/now-error';
import { installBuilders, getBuilder, cacheDirPromise } from './builder-cache';
import {
  NowConfig,
  BuildConfig,
  BuilderInputs,
  BuilderOutput,
  BuilderOutputs,
  BuiltLambda
} from './types';

/**
 * Build project to statics & lambdas
 */
export async function buildUserProject(
  nowJson: NowConfig,
  devServer: DevServer
): Promise<BuilderOutputs> {
  try {
    devServer.setStatusBusy('Installing builders');
    const builds = nowJson.builds || [];
    await installBuilders(builds.map(build => build.use));

    devServer.setStatusBusy('Building lambdas');
    const assets = await executeBuilds(nowJson, devServer);

    devServer.setStatusIdle();
    return assets;
  } catch (err) {
    devServer.setStatusIdle();
    throw err;
  }
}

async function executeBuilds(
  nowJson: NowConfig,
  devServer: DevServer
): Promise<BuilderOutputs> {
  const { cwd } = devServer;
  const files = await collectProjectFiles('**', cwd);
  let results: BuilderOutputs = {};

  if (!nowJson.builds) {
    return results;
  }

  const cacheDir = await cacheDirPromise;

  for (const build of nowJson.builds) {
    try {
      devServer.logDebug(`Build ${JSON.stringify(build)}`);
      const builder = await getBuilder(build.use);
      build.builder = builder;

      const entries = Object.values(await collectProjectFiles(build.src, cwd));

      for (const entry of entries) {
        const config = build.config || {};
        const entrypoint = relative(cwd, entry.fsPath);
        const { dev, ino } = await stat(entrypoint);
        const workPath = join(cacheDir, 'workPaths', String(dev + ino));
        devServer.logDebug(`Building ${entry.fsPath} (workPath = ${workPath})`);
        await mkdirp(workPath);
        const output = await builder.build({
          files,
          entrypoint,
          workPath,
          config,
          isDev: true
        });

        for (const asset of Object.values(output)) {
          asset.buildConfig = build;
        }

        Object.assign(results, output);
      }
    } catch (err) {
      throw err;
      /*
      throw new NowError({
        code: 'NOW_BUILDER_FAILURE',
        message: `Failed building ${chalk.bold(build.src)} with ${build.use}`,
        meta: err.stack
      });
       */
    }
  }

  await Promise.all(
    Object.values(results).map(async (asset: BuilderOutput) => {
      if (asset.type !== 'Lambda') return;
      asset.fn = await createFunction({
        Code: { ZipFile: asset.zipBuffer },
        Handler: asset.handler,
        Runtime: asset.runtime,
        Environment: {
          Variables: {
            // TODO: resolve secret env vars
            ...nowJson.env,
            ...asset.environment,
            NOW_REGION: 'dev1'
          }
        }
      });
    })
  );

  return results;
}

/**
 * Collect project files, with .gitignore and .nowignore honored.
 */
export async function collectProjectFiles(
  pattern: string,
  cwd: string
): Promise<BuilderInputs> {
  const ignore = await createIgnoreList(cwd);
  const files = await globBuilderInputs(pattern, { cwd, ignore });
  return files;
}

/**
 * Create ignore list according .gitignore & .nowignore in cwd
 */
export async function createIgnoreList(cwd: string): Promise<Ignore> {
  const ig = ignore();

  // Add the default ignored files
  ig.add(IGNORED);

  // Special case for now-cli's usage
  ig.add('.nowignore');

  // Temp workround for excluding ncc/ & user/ folder generated by builders
  // should be removed later.
  ig.add('ncc');
  ig.add('user');

  try {
    const gitignore = join(cwd, '.gitignore');
    ig.add(await readFile(gitignore, 'utf8'));
  } catch (err) {
    if (err.code !== 'ENOENT') {
      throw err;
    }
  }

  try {
    const nowignore = join(cwd, '.nowignore');
    ig.add(await readFile(nowignore, 'utf8'));
  } catch (err) {
    if (err.code !== 'ENOENT') {
      throw err;
    }
  }

  return ig;
}
