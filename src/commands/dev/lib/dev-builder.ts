import fs from 'fs';
import path from 'path';
import chalk from 'chalk';
import ignore from 'ignore';
import { createFunction } from '@zeit/fun';
import FileFsRef from '@now/build-utils/file-fs-ref';

import { glob } from './glob';
import DevServer from './dev-server';
import wait from '../../../util/output/wait';
import IGNORED from '../../../util/ignored';
import { NowError } from '../../../util/now-error';
import { installBuilders, getBuilder } from './builder-cache';
import {
  NowConfig,
  BuildConfig,
  BuilderInputs,
  BuilderOutput,
  BuilderOutputs,
  BuiltLambda
} from './types';

/**
 * Build project to statics & lambdas
 */
export async function buildUserProject(
  nowJson: NowConfig,
  devServer: DevServer
): Promise<BuilderOutputs> {
  try {
    devServer.setStatusBusy('Installing builders');
    const builds = nowJson.builds || [];
    await installBuilders(builds.map(build => build.use));

    devServer.setStatusBusy('Building lambdas');
    const assets = await executeBuilds(nowJson, devServer);

    devServer.setStatusIdle();
    return assets;
  } catch (err) {
    devServer.setStatusIdle();
    throw err;
  }
}

async function executeBuilds(
  nowJson: NowConfig,
  devServer: DevServer
): Promise<BuilderOutputs> {
  const { cwd } = devServer;
  const files = await collectProjectFiles('**', cwd);
  let results: BuilderOutputs = {};

  if (!nowJson.builds) {
    return results;
  }

  for (const build of nowJson.builds) {
    try {
      devServer.logDebug(`Build ${JSON.stringify(build)}`);
      const builder = await getBuilder(build.use);
      build.builder = builder;

      const entries = Object.values(await collectProjectFiles(build.src, cwd));

      for (const entry of entries) {
        const output = await builder.build({
          files,
          entrypoint: path.relative(cwd, entry.fsPath),
          workPath: cwd,
          config: build.config || {},
          isDev: true
        });

        for (const asset of Object.values(output)) {
          asset.buildConfig = build;
        }

        Object.assign(results, output);
      }
    } catch (err) {
      throw err;
      /*
      throw new NowError({
        code: 'NOW_BUILDER_FAILURE',
        message: `Failed building ${chalk.bold(build.src)} with ${build.use}`,
        meta: err.stack
      });
       */
    }
  }

  await Promise.all(
    Object.values(results).map(async (asset: BuilderOutput) => {
      if (asset.type !== 'Lambda') return;
      asset.fn = await createFunction({
        Code: { ZipFile: asset.zipBuffer },
        Handler: asset.handler,
        Runtime: asset.runtime,
        Environment: {
          Variables: {
            // TODO: resolve secret env vars
            ...nowJson.env,
            ...asset.environment,
            NOW_REGION: 'dev1'
          }
        }
      });
    })
  );

  return results;
}

/**
 * Collect project files, with .gitignore and .nowignore honored.
 */
export async function collectProjectFiles(pattern: string, cwd: string): Promise<BuilderInputs> {
  const ignore = await createIgnoreList(cwd);
  const files = await glob(pattern, { cwd, ignore });
  return files;
}

/**
 * Create ignore list according .gitignore & .nowignore in cwd
 */
export async function createIgnoreList(cwd: string): Promise<any> {
  const ig = ignore();

  // Add the default ignored files
  ig.add(IGNORED);

  // Special case for now-cli's usage
  ig.add('.nowignore');

  // Temp workround for excluding ncc/ & user/ folder generated by builders
  // should be removed later.
  ig.add('ncc');
  ig.add('user');

  try {
    const gitignore = path.join(cwd, '.gitignore');
    ig.add(fs.readFileSync(gitignore, 'utf8'));
  } catch (err) {
    if (err.code !== 'ENOENT') {
      throw err;
    }
  }

  try {
    const nowignore = path.join(cwd, '.nowignore');
    ig.add(fs.readFileSync(nowignore, 'utf8'));
  } catch (err) {
    if (err.code !== 'ENOENT') {
      throw err;
    }
  }

  return ig;
}
